import 'dart:developer';
import 'package:solana/solana.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:chumbucket/services/multisig_service.dart';
import 'package:chumbucket/models/models.dart';

class ChallengeService {
  final SupabaseClient _supabase;
  final SolanaClient _solanaClient;
  late final MultisigService _multisigService;

  // Platform configuration
  static const double PLATFORM_FEE_PERCENTAGE = 0.01; // 1%
  static const double MIN_FEE_SOL = 0.001; // Minimum fee in SOL
  static const double MAX_FEE_SOL =
      0.1; // Maximum fee in SOL (~$10 at $100/SOL)

  String get platformWalletAddress =>
      dotenv.env['PLATFORM_WALLET_ADDRESS'] ??
      'CHANGEME_YourActualPlatformWalletAddress';

  ChallengeService({
    required SupabaseClient supabase,
    required SolanaClient solanaClient,
  }) : _supabase = supabase,
       _solanaClient = solanaClient {
    _multisigService = MultisigService(solanaClient: _solanaClient);
  }

  /// Calculate platform fee for a challenge
  /// Returns fee in SOL, clamped to min/max limits
  double calculatePlatformFee(double challengeAmount) {
    double fee = challengeAmount * PLATFORM_FEE_PERCENTAGE;
    return fee.clamp(MIN_FEE_SOL, MAX_FEE_SOL);
  }

  /// Get detailed fee breakdown for a challenge
  Map<String, double> getFeeBreakdown(double challengeAmount) {
    final platformFee = calculatePlatformFee(challengeAmount);
    final winnerAmount = challengeAmount - platformFee;

    return {
      'challengeAmount': challengeAmount,
      'platformFee': platformFee,
      'winnerAmount': winnerAmount,
      'feePercentage': PLATFORM_FEE_PERCENTAGE,
    };
  }

  Future<Challenge> createChallenge({
    required String title,
    required String description,
    required double amountInSol,
    required String creatorId, // Privy user ID
    required String member1Address, // Creator's wallet
    required String member2Address, // Platform wallet or second participant
    DateTime? expiresAt,
    String? participantEmail,
  }) async {
    try {
      // Calculate fees
      final feeBreakdown = getFeeBreakdown(amountInSol);
      final platformFee = feeBreakdown['platformFee']!;
      final winnerAmount = feeBreakdown['winnerAmount']!;

      // Generate a temporary challenge ID for multisig creation
      final tempChallengeId = DateTime.now().millisecondsSinceEpoch.toString();

      // Create multisig for this challenge
      final multisigInfo = await _multisigService.createChallengeMultisig(
        challengeId: tempChallengeId,
        member1Address: member1Address,
        member2Address: member2Address,
      );

      // Create challenge in database
      final challenge = Challenge(
        id: '', // Will be generated by Supabase
        creatorId: creatorId,
        participantEmail: participantEmail,
        title: title,
        description: description,
        amount: amountInSol,
        platformFee: platformFee,
        winnerAmount: winnerAmount,
        createdAt: DateTime.now(),
        expiresAt: expiresAt ?? DateTime.now().add(const Duration(days: 7)),
        status: ChallengeStatus.pending,
        multisigAddress: multisigInfo['multisig_address'],
        vaultAddress: multisigInfo['vault_address'],
      );

      final response =
          await _supabase
              .from('challenges')
              .insert(challenge.toJson())
              .select()
              .single();

      final createdChallenge = Challenge.fromJson(response);

      // TODO: Initiate deposit transaction to multisig vault
      // This will require wallet interaction from the frontend

      return createdChallenge;
    } catch (e) {
      print('Error creating challenge: $e');
      rethrow;
    }
  }

  /// Deposit funds to a challenge's multisig vault
  Future<Map<String, dynamic>> depositToChallenge({
    required String challengeId,
    required double amountSol,
    required String fromWalletAddress,
  }) async {
    try {
      final challenge = await getChallenge(challengeId);
      if (challenge == null) {
        throw Exception('Challenge not found');
      }

      final vaultAddress = challenge['vault_address'] as String?;
      if (vaultAddress == null) {
        throw Exception('Challenge vault not configured');
      }

      // Use multisig service to handle deposit
      final transactionSignature = await _multisigService.depositToVault(
        vaultAddress: vaultAddress,
        amountSol: amountSol,
        senderAddress: fromWalletAddress,
      );

      // Update challenge with transaction signature
      await _supabase
          .from('challenges')
          .update({
            'transaction_signature': transactionSignature,
            'status': 'funded',
          })
          .eq('id', challengeId);

      return {
        'transactionSignature': transactionSignature,
        'status': 'funded',
        'amount': amountSol,
      };
    } catch (e) {
      print('Error depositing to challenge: $e');
      rethrow;
    }
  }

  /// Get vault balance for a challenge
  Future<double> getChallengeVaultBalance(String challengeId) async {
    try {
      final challenge = await getChallenge(challengeId);
      if (challenge == null) {
        throw Exception('Challenge not found');
      }

      final vaultAddress = challenge['vault_address'] as String?;
      if (vaultAddress == null) {
        return 0.0;
      }

      return await _multisigService.getVaultBalance(vaultAddress);
    } catch (e) {
      print('Error getting vault balance: $e');
      return 0.0;
    }
  }

  /// Release funds from challenge vault to winner
  Future<Map<String, dynamic>> releaseFundsToWinner({
    required String challengeId,
    required String winnerId,
    required String winnerWalletAddress,
    required List<String>
    signerAddresses, // Both platform and winner signatures
  }) async {
    try {
      final challenge = await getChallenge(challengeId);
      if (challenge == null) {
        throw Exception('Challenge not found');
      }

      final multisigAddress = challenge['multisig_address'] as String?;
      final vaultAddress = challenge['vault_address'] as String?;
      final winnerAmount = challenge['winner_amount_sol'] as double?;
      final platformFee = challenge['platform_fee_sol'] as double?;

      if (multisigAddress == null ||
          vaultAddress == null ||
          winnerAmount == null ||
          platformFee == null) {
        throw Exception('Challenge configuration incomplete');
      }

      // Release winner amount to winner
      final winnerResult = await _multisigService.withdrawFromVault(
        multisigAddress: multisigAddress,
        vaultAddress: vaultAddress,
        recipientAddress: winnerWalletAddress,
        amountSol: winnerAmount,
        signerAddresses: signerAddresses,
      );

      // Release platform fee to platform wallet
      final feeResult = await _multisigService.withdrawFromVault(
        multisigAddress: multisigAddress,
        vaultAddress: vaultAddress,
        recipientAddress: platformWalletAddress,
        amountSol: platformFee,
        signerAddresses: signerAddresses,
      );

      // Update challenge as completed
      await _supabase
          .from('challenges')
          .update({
            'winner_privy_id': winnerId,
            'status': 'completed',
            'completed_at': DateTime.now().toIso8601String(),
            'transaction_signature': winnerResult,
            'fee_transaction_signature': feeResult,
          })
          .eq('id', challengeId);

      return {
        'winnerTransaction': winnerResult,
        'feeTransaction': feeResult,
        'status': 'completed',
      };
    } catch (e) {
      print('Error releasing funds: $e');
      rethrow;
    }
  }

  /// Get platform fee statistics
  Future<Map<String, dynamic>> getFeeStatistics() async {
    try {
      // Get total fees collected
      final totalFeesQuery = await _supabase
          .from('challenges')
          .select('platform_fee_sol')
          .eq('status', 'completed');

      double totalFeesCollected = 0.0;
      int completedChallenges = totalFeesQuery.length;

      for (final challenge in totalFeesQuery) {
        final fee = challenge['platform_fee_sol'] as double? ?? 0.0;
        totalFeesCollected += fee;
      }

      // Get active challenges
      final activeChallengesQuery = await _supabase
          .from('challenges')
          .select('id')
          .filter('status', 'in', '(pending,accepted,funded)');

      return {
        'totalFeesCollected': totalFeesCollected,
        'completedChallenges': completedChallenges,
        'activeChallenges': activeChallengesQuery.length,
        'averageFeePerChallenge':
            completedChallenges > 0
                ? totalFeesCollected / completedChallenges
                : 0.0,
        'feePercentage': PLATFORM_FEE_PERCENTAGE,
        'minFee': MIN_FEE_SOL,
        'maxFee': MAX_FEE_SOL,
      };
    } catch (e) {
      print('Error getting platform fee statistics: $e');
      return {};
    }
  }

  /// Get challenge by ID
  Future<Map<String, dynamic>?> getChallenge(String challengeId) async {
    try {
      final challenge =
          await _supabase
              .from('challenges')
              .select()
              .eq('id', challengeId)
              .single();

      return challenge;
    } catch (e) {
      log('Error fetching challenge: $e');
      return null;
    }
  }

  /// Get challenges for a user
  Future<List<Map<String, dynamic>>> getUserChallenges(String privyId) async {
    try {
      final challenges = await _supabase
          .from('challenges')
          .select()
          .or('creator_privy_id.eq.$privyId,participant_privy_id.eq.$privyId')
          .order('created_at', ascending: false);

      return challenges;
    } catch (e) {
      log('Error fetching user challenges: $e');
      return [];
    }
  }

  /// Accept a challenge (placeholder)
  Future<bool> acceptChallenge(
    String challengeId,
    String participantPrivyId,
  ) async {
    try {
      await _supabase
          .from('challenges')
          .update({
            'participant_privy_id': participantPrivyId,
            'status': 'accepted',
          })
          .eq('id', challengeId);

      log('Challenge accepted: $challengeId');
      return true;
    } catch (e) {
      log('Error accepting challenge: $e');
      return false;
    }
  }

  /// Complete a challenge (placeholder for actual fund release)
  Future<bool> completeChallenge(String challengeId, String winnerId) async {
    try {
      // Get challenge details
      final challenge = await getChallenge(challengeId);
      if (challenge == null) {
        log('Challenge not found: $challengeId');
        return false;
      }

      // For now, just update status (actual fund release will be implemented later)
      await _supabase
          .from('challenges')
          .update({
            'status': 'completed',
            'winner_privy_id': winnerId,
            'completed_at': DateTime.now().toIso8601String(),
          })
          .eq('id', challengeId);

      // Record platform fee (placeholder)
      await _supabase.from('platform_fees').insert({
        'challenge_id': challengeId,
        'amount_sol': challenge['platform_fee_sol'],
        'fee_percentage': PLATFORM_FEE_PERCENTAGE,
        'transaction_signature':
            'placeholder_signature', // Will be real signature later
      });

      log('Challenge completed: $challengeId, winner: $winnerId');
      return true;
    } catch (e) {
      log('Error completing challenge: $e');
      return false;
    }
  }
}
