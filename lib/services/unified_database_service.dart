import 'dart:developer' as dev;
import '../models/models.dart';
import 'local_database_service.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

enum DatabaseMode {
  local,
  remote,
  auto, // Use local for development, remote for production
}

class UnifiedDatabaseService {
  static DatabaseMode _mode =
      DatabaseMode.local; // Default to local for development
  static SupabaseClient? _supabase;

  static void configure({
    required DatabaseMode mode,
    SupabaseClient? supabase,
  }) {
    _mode = mode;
    _supabase = supabase;
    dev.log('Database service configured with mode: ${mode.name}');
  }

  static bool get isLocal =>
      _mode == DatabaseMode.local ||
      (_mode == DatabaseMode.auto && _isInDevelopment());

  static bool _isInDevelopment() {
    // You can customize this logic based on your needs
    // For now, assume we're always in development to use local DB
    return true;
  }

  // Challenge operations
  static Future<Challenge> createChallenge({
    required String title,
    required String description,
    required double amountInSol,
    required String creatorId,
    required String member1Address,
    required String member2Address,
    DateTime? expiresAt,
    String? participantEmail,
    String? escrowAddress,
    String? vaultAddress,
    required double platformFee,
    required double winnerAmount,
  }) async {
    try {
      final challenge = Challenge(
        id: '', // Will be generated by the database service
        creatorId: creatorId,
        participantEmail: participantEmail,
        title: title,
        description: description,
        amount: amountInSol,
        platformFee: platformFee,
        winnerAmount: winnerAmount,
        createdAt: DateTime.now(),
        expiresAt: expiresAt ?? DateTime.now().add(const Duration(days: 7)),
        status: ChallengeStatus.pending,
        multisigAddress: escrowAddress,
        vaultAddress: vaultAddress,
      );

      if (isLocal) {
        final id = await LocalDatabaseService.insertChallenge(challenge);
        final createdChallenge = await LocalDatabaseService.getChallenge(id);
        if (createdChallenge == null) {
          throw Exception('Failed to retrieve created challenge');
        }
        dev.log('Challenge created locally with ID: $id');
        return createdChallenge;
      } else {
        // Remote Supabase logic
        if (_supabase == null) {
          throw Exception('Supabase client not configured for remote mode');
        }

        final response =
            await _supabase!
                .from('challenges')
                .insert({
                  'creator_privy_id': challenge.creatorId,
                  'participant_privy_id': challenge.participantId,
                  'participant_email': challenge.participantEmail,
                  'title': challenge.title,
                  'description': challenge.description,
                  'amount': challenge.amount, // Try without _sol suffix
                  'platform_fee': challenge.platformFee,
                  'winner_amount': challenge.winnerAmount,
                  'created_at': challenge.createdAt.toIso8601String(),
                  'expires_at': challenge.expiresAt.toIso8601String(),
                  'completed_at': challenge.completedAt?.toIso8601String(),
                  'status': challenge.status.toString().split('.').last,
                  'multisig_address': challenge.multisigAddress,
                  'vault_address': challenge.vaultAddress,
                  'winner_privy_id': challenge.winnerId,
                  'transaction_signature': challenge.transactionSignature,
                  'fee_transaction_signature':
                      challenge.feeTransactionSignature,
                })
                .select()
                .single();

        final createdChallenge = Challenge.fromJson(response);
        dev.log('Challenge created remotely with ID: ${createdChallenge.id}');
        return createdChallenge;
      }
    } catch (e) {
      dev.log('Error creating challenge: $e');
      rethrow;
    }
  }

  static Future<Challenge?> getChallenge(String id) async {
    try {
      if (isLocal) {
        return await LocalDatabaseService.getChallenge(id);
      } else {
        if (_supabase == null) {
          throw Exception('Supabase client not configured for remote mode');
        }

        final response =
            await _supabase!.from('challenges').select().eq('id', id).single();

        return Challenge.fromJson(response);
      }
    } catch (e) {
      dev.log('Error getting challenge: $e');
      return null;
    }
  }

  static Future<List<Challenge>> getChallengesForUser(
    String userPrivyId,
  ) async {
    try {
      if (isLocal) {
        return await LocalDatabaseService.getChallengesForUser(userPrivyId);
      } else {
        if (_supabase == null) {
          throw Exception('Supabase client not configured for remote mode');
        }

        final response = await _supabase!
            .from('challenges')
            .select()
            .or(
              'creator_privy_id.eq.$userPrivyId,participant_privy_id.eq.$userPrivyId',
            )
            .order('created_at', ascending: false);

        return response.map((json) => Challenge.fromJson(json)).toList();
      }
    } catch (e) {
      dev.log('Error getting challenges for user: $e');
      return [];
    }
  }

  static Future<bool> updateChallenge(
    String id,
    Map<String, dynamic> updates,
  ) async {
    try {
      if (isLocal) {
        final rowsAffected = await LocalDatabaseService.updateChallenge(
          id,
          updates,
        );
        return rowsAffected > 0;
      } else {
        if (_supabase == null) {
          throw Exception('Supabase client not configured for remote mode');
        }

        await _supabase!.from('challenges').update(updates).eq('id', id);

        return true;
      }
    } catch (e) {
      dev.log('Error updating challenge: $e');
      return false;
    }
  }

  /// Convenience method for updating challenge status
  static Future<bool> updateChallengeStatus(
    String id,
    String status, {
    String? transactionSignature,
    String? winnerId,
    DateTime? completedAt,
  }) async {
    final updates = <String, dynamic>{
      'status': status,
      // Note: Local database doesn't have updated_at column, so we don't include it
    };

    if (transactionSignature != null) {
      updates['transaction_signature'] = transactionSignature;
    }
    if (winnerId != null) {
      updates['winner_privy_id'] = winnerId;
    }
    if (completedAt != null) {
      updates['completed_at'] = completedAt.toIso8601String();
    }

    return await updateChallenge(id, updates);
  }

  // Platform fee operations
  static Future<String> insertPlatformFee(PlatformFee fee) async {
    try {
      if (isLocal) {
        return await LocalDatabaseService.insertPlatformFee(fee);
      } else {
        if (_supabase == null) {
          throw Exception('Supabase client not configured for remote mode');
        }

        final response =
            await _supabase!
                .from('platform_fees')
                .insert(fee.toJson())
                .select()
                .single();

        return response['id'] as String;
      }
    } catch (e) {
      dev.log('Error inserting platform fee: $e');
      rethrow;
    }
  }

  // Challenge transaction operations
  static Future<String> insertChallengeTransaction(
    ChallengeTransaction transaction,
  ) async {
    try {
      if (isLocal) {
        return await LocalDatabaseService.insertChallengeTransaction(
          transaction,
        );
      } else {
        if (_supabase == null) {
          throw Exception('Supabase client not configured for remote mode');
        }

        final response =
            await _supabase!
                .from('challenge_transactions')
                .insert(transaction.toJson())
                .select()
                .single();

        return response['id'] as String;
      }
    } catch (e) {
      dev.log('Error inserting challenge transaction: $e');
      rethrow;
    }
  }

  // Challenge participant operations
  static Future<String> insertChallengeParticipant(
    ChallengeParticipant participant,
  ) async {
    try {
      if (isLocal) {
        return await LocalDatabaseService.insertChallengeParticipant(
          participant,
        );
      } else {
        if (_supabase == null) {
          throw Exception('Supabase client not configured for remote mode');
        }

        final response =
            await _supabase!
                .from('challenge_participants')
                .insert(participant.toJson())
                .select()
                .single();

        return response['id'] as String;
      }
    } catch (e) {
      dev.log('Error inserting challenge participant: $e');
      rethrow;
    }
  }

  // Utility methods
  static Future<void> clearAllData() async {
    try {
      if (isLocal) {
        await LocalDatabaseService.clearAllData();
      } else {
        dev.log('Clear all data not implemented for remote database');
      }
    } catch (e) {
      dev.log('Error clearing data: $e');
    }
  }

  static Future<Map<String, int>> getDatabaseStats() async {
    try {
      if (isLocal) {
        return await LocalDatabaseService.getDatabaseStats();
      } else {
        // Could implement remote stats if needed
        return {};
      }
    } catch (e) {
      dev.log('Error getting database stats: $e');
      return {};
    }
  }

  static Future<void> switchToLocal() async {
    _mode = DatabaseMode.local;
    dev.log('Switched to local database mode');
  }

  static Future<void> switchToRemote() async {
    _mode = DatabaseMode.remote;
    dev.log('Switched to remote database mode');
  }

  static String get currentMode => isLocal ? 'Local SQLite' : 'Remote Supabase';
}
