import 'dart:developer';
import 'dart:typed_data';
import 'package:solana/solana.dart';

/// Service for interacting with the deployed chumbucket-escrow Anchor program
///
/// This service provides methods to create and manage challenges using the
/// deployed Anchor program at Es4Z5VVh54APWZ2LFy1FRebbHwPpSpA8W47oAfPrA4bV
class EscrowService {
  // Your deployed chumbucket-escrow program ID
  static const String PROGRAM_ID =
      'Es4Z5VVh54APWZ2LFy1FRebbHwPpSpA8W47oAfPrA4bV';

  EscrowService({required SolanaClient client});

  /// Create a challenge escrow using the deployed Anchor program
  ///
  /// This method builds the proper Anchor instruction for creating a challenge
  /// in your deployed chumbucket-escrow program.
  Future<Map<String, dynamic>> createChallenge({
    required String initiatorAddress,
    required String witnessAddress,
    required double amountSol,
    required int durationDays,
  }) async {
    try {
      log('Creating escrow challenge with Anchor program:');
      log('  Program ID: $PROGRAM_ID');
      log('  Initiator: $initiatorAddress');
      log('  Witness: $witnessAddress');
      log('  Amount: ${amountSol.toStringAsFixed(4)} SOL');
      log('  Duration: $durationDays days');

      // Convert SOL to lamports
      final amountLamports = (amountSol * lamportsPerSol).round();

      // Calculate deadline (current time + duration in seconds)
      final deadlineTimestamp =
          DateTime.now().millisecondsSinceEpoch ~/ 1000 +
          (durationDays * 24 * 60 * 60);

      // Generate a new keypair for the challenge account
      final challengeKeypair = await Ed25519HDKeyPair.random();

      // Build the instruction data for create_challenge
      // This uses the exact discriminator from your Anchor program
      final instructionData = _buildCreateChallengeData(
        amountLamports,
        deadlineTimestamp,
      );

      // For now, return a mock structure until we resolve the solana package API
      // The wallet provider will handle the actual transaction building

      log('✅ Challenge structure created for Anchor program');

      // Return challenge info for wallet provider to execute
      return {
        'challengeKeypair': challengeKeypair,
        'challengeAddress': challengeKeypair.publicKey.toBase58(),
        'initiator': initiatorAddress,
        'witness': witnessAddress,
        'amount': amountLamports,
        'deadline': deadlineTimestamp,
        'programId': PROGRAM_ID,
        'instructionData': instructionData,
        'status': 'pending',
      };
    } catch (e) {
      log('❌ Error creating challenge: $e');
      rethrow;
    }
  }

  /// Build instruction data for create_challenge with proper Anchor discriminator
  Uint8List _buildCreateChallengeData(
    int amountLamports,
    int deadlineTimestamp,
  ) {
    final buffer = BytesBuilder();

    // Anchor instruction discriminator for create_challenge
    // This is generated by Anchor based on the method name
    buffer.add([170, 244, 47, 1, 1, 15, 173, 239]);

    // Serialize arguments according to Anchor's Borsh serialization:

    // Amount (u64, little endian)
    final amountBytes = Uint8List(8);
    ByteData.view(
      amountBytes.buffer,
    ).setUint64(0, amountLamports, Endian.little);
    buffer.add(amountBytes);

    // Deadline (i64, little endian)
    final deadlineBytes = Uint8List(8);
    ByteData.view(
      deadlineBytes.buffer,
    ).setInt64(0, deadlineTimestamp, Endian.little);
    buffer.add(deadlineBytes);

    return buffer.toBytes();
  }

  /// Validate challenge parameters before creation
  static Map<String, dynamic> validateChallenge({
    required double amountSol,
    required int durationDays,
  }) {
    final errors = <String>[];

    // Validate amount
    if (amountSol <= 0) {
      errors.add('Amount must be greater than 0');
    }
    if (amountSol < 0.001) {
      errors.add('Minimum amount is 0.001 SOL');
    }
    if (amountSol > 100) {
      errors.add('Maximum amount is 100 SOL');
    }

    // Validate duration
    if (durationDays <= 0) {
      errors.add('Duration must be greater than 0 days');
    }
    if (durationDays > 365) {
      errors.add('Maximum duration is 365 days');
    }

    return {'isValid': errors.isEmpty, 'errors': errors};
  }
}
